# Python Monorepo Release Automation Guide

> Complete guide to structure Python packages, set up GitHub Actions automation, and trigger releases via git tags

---

## 📑 Quick Navigation

- [Quick Start](#-quick-start-python-release) - Get your first Python release live in 15 minutes
- [Python Package Structure](#-python-package-structure) - How to organize files
- [GitHub Actions Workflow](#-github-actions-workflow) - Automated CI/CD
- [Tag & Release](#-tag-and-release-flow) - Trigger releases with tags
- [Complete Example](#-complete-example-walkthrough) - Real step-by-step
- [Troubleshooting](#-troubleshooting) - Fix common issues

---

## ⚡ Quick Start: Python Release

### Prerequisites

```bash
# Check Python version (3.9+)
python3 --version

# Check pip
pip3 --version

# Install build tools
pip3 install build twine

# Verify git and git-flow
git --version
git flow version 2>/dev/null || brew install git-flow-avh
```

### Your First Python Package Release (15 minutes)

```bash
# 1. Navigate to package
cd packages/package-a

# 2. Make Python code changes
echo 'def hello(): return "Hello from package-a v1.1.0!"' >> src/hello.py

# 3. Commit with conventional format
git add .
git commit -m "feat(package-a): add hello function"

# 4. Merge to main via git-flow
git flow release start 1.1.0
cd ../..
git flow release finish 1.1.0 -m "Release package-a v1.1.0"

# 5. Create and push tag (triggers GitHub Action)
git tag -a package-a@v1.1.0 -m "Release package-a v1.1.0"
git push origin main develop --tags

# ✅ GitHub Action automatically:
#    - Checks out code
#    - Installs Python dependencies
#    - Runs tests
#    - Builds distribution packages
#    - Creates GitHub release
#    - Publishes to PyPI (optional)
```

---

## 📦 Python Package Structure

### Recommended Directory Layout

```
packages/package-a/
│
├── src/                          # Source code
│   ├── __init__.py
│   ├── logger.py
│   ├── utils.py
│   └── __version__.py            # Single source of truth for version
│
├── tests/                        # Test suite
│   ├── __init__.py
│   ├── test_logger.py
│   ├── test_utils.py
│   └── conftest.py              # pytest configuration
│
├── docs/                         # Documentation
│   ├── index.md
│   ├── api.md
│   └── examples.md
│
├── pyproject.toml               # Modern Python packaging (PEP 518)
├── setup.py                     # Legacy setup (optional)
├── setup.cfg                    # Configuration
├── MANIFEST.in                  # Include extra files in dist
├── README.md                    # Package documentation
├── CHANGELOG.md                 # Auto-generated by release-it
├── LICENSE                      # MIT, Apache, etc.
├── .release-it.json             # Release configuration
├── pytest.ini                   # Pytest configuration
├── mypy.ini                     # Type checking config
└── tox.ini                      # Testing multiple Python versions
```

### File: `pyproject.toml` (Modern Standard)

```toml
[build-system]
requires = ["setuptools>=68.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "package-a"
dynamic = ["version"]  # Read from __init__.py or __version__.py
description = "Core functionality package"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
authors = [{name = "Your Team", email = "team@example.com"}]
keywords = ["example", "core", "utilities"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

dependencies = [
    "requests>=2.28.0",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "black>=23.0",
    "ruff>=0.1.0",
    "mypy>=1.0",
    "sphinx>=6.0",
]
test = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
]

[project.urls]
Homepage = "https://github.com/codefuturist/monorepository-example"
Repository = "https://github.com/codefuturist/monorepository-example.git"
"Bug Tracker" = "https://github.com/codefuturist/monorepository-example/issues"

[tool.setuptools]
packages = ["src"]

[tool.setuptools.dynamic]
version = {attr = "src.__version__.__version__"}

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
addopts = "--cov=src --cov-report=html --cov-report=term"

[tool.mypy]
python_version = "3.9"
disallow_untyped_defs = true
strict = true

[tool.black]
line-length = 100
target-version = ["py39"]

[tool.ruff]
line-length = 100
target-version = "py39"
select = ["E", "F", "W", "I"]
```

### File: `src/__init__.py`

```python
"""Package A - Core functionality."""

from src.__version__ import __version__

__all__ = ["__version__"]
```

### File: `src/__version__.py`

```python
"""Version information for package-a."""

__version__ = "1.1.0"
```

### File: `src/logger.py` (Example Module)

```python
"""Logging utilities for package-a."""

import logging
from typing import Optional

def setup_logger(
    name: str,
    level: int = logging.INFO,
    log_file: Optional[str] = None,
) -> logging.Logger:
    """
    Set up a logger with optional file output.

    Args:
        name: Logger name
        level: Logging level
        log_file: Optional file to log to

    Returns:
        Configured logger instance
    """
    logger = logging.getLogger(name)
    logger.setLevel(level)

    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )

    # Console handler
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    # File handler (optional)
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    return logger
```

### File: `tests/test_logger.py`

```python
"""Tests for logging utilities."""

import logging
from src.logger import setup_logger


def test_setup_logger():
    """Test logger setup."""
    logger = setup_logger("test_logger")
    assert isinstance(logger, logging.Logger)
    assert logger.name == "test_logger"


def test_logger_level():
    """Test logger level."""
    logger = setup_logger("test_logger", level=logging.DEBUG)
    assert logger.level == logging.DEBUG
```

### File: `pytest.ini`

```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    --cov=src
    --cov-report=html
    --cov-report=term
    --strict-markers
    -v

markers =
    unit: Unit tests
    integration: Integration tests
    slow: Slow running tests
```

### File: `MANIFEST.in`

```
include README.md
include LICENSE
include CHANGELOG.md
recursive-include tests *.py
recursive-include docs *.md
```

---

## 🤖 GitHub Actions Workflow

### File: `.github/workflows/python-release.yml`

Complete Python-focused release workflow:

```yaml
name: Python Release

on:
  push:
    tags:
      - "package-*@v*.*.*" # Individual package releases
      - "v*.*.*" # Monorepo releases

permissions:
  contents: write
  packages: write
  id-token: write # For trusted publishing

jobs:
  build-and-test:
    name: Build & Test Python Package
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]

    steps:
      # 1. Checkout code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2. Setup Python
      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      # 3. Install build tools
      - name: Install build tools
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install build twine
          pip install pytest pytest-cov black ruff mypy

      # 4. Extract tag info
      - name: Extract tag info
        id: tag_info
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          echo "tag=$TAG" >> $GITHUB_OUTPUT

          if [[ $TAG == package-*@v* ]]; then
            PACKAGE_NAME=$(echo $TAG | cut -d'@' -f1)
            VERSION=$(echo $TAG | cut -d'@' -f2)
            echo "package=$PACKAGE_NAME" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "is_package=true" >> $GITHUB_OUTPUT
            echo "package_path=packages/$PACKAGE_NAME" >> $GITHUB_OUTPUT
          else
            echo "version=$TAG" >> $GITHUB_OUTPUT
            echo "is_package=false" >> $GITHUB_OUTPUT
          fi
          echo "Full tag: $TAG"

      # 5. Install package dependencies
      - name: Install package dependencies
        run: |
          if [ "${{ steps.tag_info.outputs.is_package }}" = "true" ]; then
            cd ${{ steps.tag_info.outputs.package_path }}
            pip install -e ".[test]"
          else
            # Install all packages for monorepo release
            for pkg in packages/*/; do
              cd "$pkg"
              pip install -e ".[test]"
              cd ../..
            done
          fi

      # 6. Run linting
      - name: Lint with ruff
        if: matrix.python-version == '3.12'
        run: |
          if [ "${{ steps.tag_info.outputs.is_package }}" = "true" ]; then
            ruff check ${{ steps.tag_info.outputs.package_path }}/src
          else
            ruff check packages/*/src
          fi
        continue-on-error: true

      # 7. Type checking
      - name: Type check with mypy
        if: matrix.python-version == '3.12'
        run: |
          if [ "${{ steps.tag_info.outputs.is_package }}" = "true" ]; then
            mypy ${{ steps.tag_info.outputs.package_path }}/src
          else
            for pkg in packages/*/src; do
              mypy "$pkg"
            done
          fi
        continue-on-error: true

      # 8. Run tests
      - name: Run pytest
        run: |
          if [ "${{ steps.tag_info.outputs.is_package }}" = "true" ]; then
            cd ${{ steps.tag_info.outputs.package_path }}
            pytest
          else
            for pkg in packages/*/; do
              cd "$pkg"
              pytest
              cd ../..
            done
          fi

      # 9. Build distribution
      - name: Build distribution package
        run: |
          if [ "${{ steps.tag_info.outputs.is_package }}" = "true" ]; then
            cd ${{ steps.tag_info.outputs.package_path }}
            python -m build
            echo "Built package at: ${{ steps.tag_info.outputs.package_path }}/dist"
            ls -lh dist/
          fi

      # 10. Upload artifacts
      - name: Upload artifacts
        if: steps.tag_info.outputs.is_package == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: python-packages-${{ matrix.python-version }}
          path: ${{ steps.tag_info.outputs.package_path }}/dist/

  publish:
    name: Publish Python Package
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Extract tag info
        id: tag_info
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          echo "tag=$TAG" >> $GITHUB_OUTPUT

          if [[ $TAG == package-*@v* ]]; then
            PACKAGE_NAME=$(echo $TAG | cut -d'@' -f1)
            VERSION=$(echo $TAG | cut -d'@' -f2)
            echo "package=$PACKAGE_NAME" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "package_path=packages/$PACKAGE_NAME" >> $GITHUB_OUTPUT
          fi

      - name: Download artifacts
        uses: actions/download-artifact@v3
        with:
          name: python-packages-3.12
          path: dist/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag_info.outputs.tag }}
          name: ${{ steps.tag_info.outputs.package }} v${{ steps.tag_info.outputs.version }}
          body: |
            ## Python Package Release

            **Package:** ${{ steps.tag_info.outputs.package }}
            **Version:** ${{ steps.tag_info.outputs.version }}

            Built for Python 3.9, 3.10, 3.11, 3.12

            [View CHANGELOG](https://github.com/${{ github.repository }}/blob/${{ steps.tag_info.outputs.tag }}/CHANGELOG.md)
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            dist/*.whl
            dist/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Optional: Publish to PyPI
      - name: Publish to PyPI
        if: steps.tag_info.outputs.package != ''
        run: |
          pip install twine
          python -m twine upload dist/* --skip-existing
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        continue-on-error: true
```

### File: `.github/workflows/python-ci.yml` (Test on Pull Requests)

```yaml
name: Python CI

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [develop]

jobs:
  test:
    name: Test Python Packages
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.12"]

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build pytest pytest-cov

      - name: Install all packages
        run: |
          for pkg in packages/*/; do
            cd "$pkg"
            pip install -e ".[test]"
            cd ../..
          done

      - name: Run tests
        run: |
          for pkg in packages/*/; do
            cd "$pkg"
            pytest --cov
            cd ../..
          done
```

---

## 🏷️ Tag and Release Flow

### How Tags Trigger the Workflow

```bash
# 1. Make your changes and commit
cd packages/package-a
echo 'def greet(name): return f"Hello, {name}!"' >> src/hello.py
git add .
git commit -m "feat(package-a): add greet function"

# 2. Finish release with git-flow
git checkout main
git flow release start 1.2.0
cd ../..
git flow release finish 1.2.0 -m "Release 1.2.0"

# 3. Create annotated tag (important!)
git tag -a package-a@v1.2.0 -m "Release package-a v1.2.0"

# 4. Push everything
git push origin main develop --tags

# 5. GitHub Action automatically:
#    ✅ Detects tag push
#    ✅ Runs tests on Python 3.9, 3.10, 3.11, 3.12
#    ✅ Builds wheel and sdist
#    ✅ Creates GitHub release with artifacts
#    ✅ Optionally publishes to PyPI
```

### Verify Tag Was Pushed

```bash
# List all tags
git tag -l

# Show specific tag
git show package-a@v1.2.0

# Check remote tags
git ls-remote --tags origin

# Look for workflow run
# GitHub repo → Actions → Python Release
```

---

## 📋 Complete Example Walkthrough

### Step 1: Create Python Package Structure

```bash
# Navigate to package
cd packages/package-a

# Create src directory if not exists
mkdir -p src tests

# Create __init__.py
cat > src/__init__.py << 'EOF'
"""Package A - Core functionality."""

from src.__version__ import __version__

__all__ = ["__version__"]
EOF

# Create version file
cat > src/__version__.py << 'EOF'
"""Version information."""

__version__ = "1.2.0"
EOF

# Create sample module
cat > src/calculator.py << 'EOF'
"""Simple calculator module."""

def add(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b

def multiply(a: int, b: int) -> int:
    """Multiply two numbers."""
    return a * b
EOF

# Create test file
cat > tests/test_calculator.py << 'EOF'
"""Tests for calculator module."""

from src.calculator import add, multiply


def test_add():
    """Test addition."""
    assert add(2, 3) == 5
    assert add(-1, 1) == 0


def test_multiply():
    """Test multiplication."""
    assert multiply(3, 4) == 12
    assert multiply(0, 100) == 0
EOF

cd ../..
```

### Step 2: Create pyproject.toml

```bash
cd packages/package-a

cat > pyproject.toml << 'EOF'
[build-system]
requires = ["setuptools>=68.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "package-a"
version = "1.2.0"
description = "Core functionality package"
readme = "README.md"
requires-python = ">=3.9"
license = {text = "MIT"}
authors = [{name = "Your Team", email = "team@example.com"}]

dependencies = []

[project.optional-dependencies]
test = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
]

[tool.setuptools]
packages = ["src"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
addopts = "--cov=src --cov-report=html"
EOF

cd ../..
```

### Step 3: Install and Test Locally

```bash
cd packages/package-a

# Install package in development mode
pip install -e ".[test]"

# Run tests
pytest

# Expected output:
# tests/test_calculator.py::test_add PASSED
# tests/test_calculator.py::test_multiply PASSED
# ========================= 2 passed in 0.05s =========================

cd ../..
```

### Step 4: Create Release with Git Flow

```bash
# Start release
git flow release start 1.2.0

# Update version in src/__version__.py if needed
# (or use release-it to auto-update)

# Commit changes
cd packages/package-a
git add -A
git commit -m "chore(package-a): bump version to 1.2.0"
cd ../..

# Finish release
git flow release finish 1.2.0 -m "Release package-a v1.2.0"
```

### Step 5: Create Tag and Push

```bash
# Create annotated tag
git tag -a package-a@v1.2.0 -m "Release package-a v1.2.0"

# Push everything
git push origin main develop --tags

# Verify push
git ls-remote --tags origin | grep package-a
```

### Step 6: Watch GitHub Action

```
1. Go to GitHub repo
2. Click "Actions" tab
3. Select "Python Release" workflow
4. Watch the build run:
   ✅ Checkout code
   ✅ Setup Python (matrix: 3.9, 3.10, 3.11, 3.12)
   ✅ Install dependencies
   ✅ Run tests
   ✅ Build distribution (wheel + sdist)
   ✅ Create GitHub release
   ✅ Upload artifacts
```

### Step 7: Check GitHub Release

```
1. Go to GitHub repo
2. Click "Releases"
3. See "package-a v1.2.0" with:
   - Wheel file (.whl)
   - Source distribution (.tar.gz)
   - Automatically generated release notes
```

---

## 🛠️ Best Practices

### 1. Version Management

```python
# DON'T: Hard-code versions
VERSION = "1.2.0"  # ❌ Easy to forget updating

# DO: Single source of truth
# In src/__version__.py
__version__ = "1.2.0"

# Access in src/__init__.py
from src.__version__ import __version__

# Access in pyproject.toml
# dynamic = ["version"]
# Read from: src/__version__.py
```

### 2. Testing Best Practices

```bash
# Run tests locally before pushing
pytest --cov=src --cov-report=term

# Run tests on multiple Python versions
tox

# Example tox.ini
[tox]
envlist = py39,py310,py311,py312

[testenv]
deps = pytest pytest-cov
commands = pytest
```

### 3. Package Metadata

```toml
# Comprehensive pyproject.toml
[project]
name = "package-a"
version = "1.2.0"
description = "Core functionality"
readme = "README.md"
requires-python = ">=3.9"

license = {text = "MIT"}
authors = [{name = "Team", email = "team@example.com"}]
keywords = ["core", "utilities"]

classifiers = [
    "Development Status :: 4 - Beta",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
]

[project.urls]
Homepage = "https://github.com/codefuturist/monorepository-example"
Repository = "https://github.com/codefuturist/monorepository-example.git"
"Bug Tracker" = "https://github.com/codefuturist/monorepository-example/issues"
```

### 4. Continuous Integration

```yaml
# Always test on multiple Python versions
strategy:
  matrix:
    python-version: ['3.9', '3.10', '3.11', '3.12']

# Always run linting and type checking
- name: Lint
  run: ruff check src

- name: Type check
  run: mypy src
```

### 5. PyPI Publishing

```bash
# Test locally first (test PyPI)
python -m twine upload --repository testpypi dist/*

# Create PyPI token at pypi.org
# Add as GitHub secret: PYPI_API_TOKEN

# Use trusted publishing (recommended)
# No need to store tokens in secrets
```

---

## ⚠️ Troubleshooting

### Issue: "Action not triggering on tag push"

**Solution:**

```bash
# Verify tag was created and pushed
git tag -l | grep package-a

# Check if pushed to remote
git ls-remote --tags origin

# Re-push if needed
git push origin package-a@v1.2.0 --force

# Check Actions tab for workflow runs
```

### Issue: "Tests fail in CI but pass locally"

**Solution:**

```bash
# Install full test dependencies
pip install -e ".[test]"

# Run same tests as CI
pytest --cov=src

# Check Python version matches
python --version

# Run on all supported versions
tox
```

### Issue: "Build fails - package not found"

**Solution:**

```bash
# Check package structure
ls -la packages/package-a/src/

# Verify __init__.py exists in src
touch packages/package-a/src/__init__.py

# Check pyproject.toml has correct packages declaration
[tool.setuptools]
packages = ["src"]
```

### Issue: "Import error: No module named 'src'"

**Solution:**

```bash
# Install in development mode
pip install -e packages/package-a

# Or specify the package path
PYTHONPATH=packages/package-a pytest

# Check sys.path in tests
import sys
print(sys.path)
```

### Issue: "PyPI publish fails - unauthorized"

**Solution:**

```bash
# Create token at pypi.org
# Account Settings → API tokens → Add token

# Add to GitHub Secrets
# Repo Settings → Secrets → New Repository Secret
# Name: PYPI_API_TOKEN
# Value: pypi-ag...

# Use in workflow
env:
  TWINE_USERNAME: __token__
  TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
```

---

## 📚 Quick Reference

### Common Commands

```bash
# Test locally
pytest
pytest --cov
pytest -v

# Build package
python -m build

# Check distribution
twine check dist/*

# Verify package
pip install dist/package_a-1.2.0-py3-none-any.whl

# Create tag
git tag -a package-a@v1.2.0 -m "Release"

# Push tag
git push origin package-a@v1.2.0

# Show tag
git show package-a@v1.2.0

# Delete tag (local)
git tag -d package-a@v1.2.0

# Delete tag (remote)
git push origin :refs/tags/package-a@v1.2.0
```

### File Checklist

For each Python package:

- ✅ `src/__init__.py` - Package initialization
- ✅ `src/__version__.py` - Version definition
- ✅ `pyproject.toml` - Modern packaging config
- ✅ `tests/` - Test suite
- ✅ `pytest.ini` - Test configuration
- ✅ `README.md` - Package documentation
- ✅ `LICENSE` - License file
- ✅ `CHANGELOG.md` - Auto-generated changelog
- ✅ `.release-it.json` - Release configuration
- ✅ `.github/workflows/python-release.yml` - Release automation
- ✅ `.github/workflows/python-ci.yml` - CI automation

---

## ✨ Summary

Your Python monorepo is now ready for:

1. **⚡ Local Development**: Write code, run tests, iterate
2. **📦 Python Packaging**: Build wheels and distributions
3. **🚀 Automated CI/CD**: GitHub Actions run tests on push
4. **🏷️ Tag-Based Release**: Push tag → GitHub Action → Release
5. **📝 Auto Release Notes**: GitHub generates changelogs
6. **📤 PyPI Publishing**: Optional automatic publishing

**Next Steps:**

1. Run the complete walkthrough above
2. Adapt examples to your packages
3. Create first release tag
4. Watch GitHub Action deploy your package

---

**Happy Python releasing! 🐍🚀**
